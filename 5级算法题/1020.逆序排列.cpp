/*
基准时间限制：2 秒 空间限制：131072 KB 分值: 80 难度：5级算法题 收藏  关注
在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。
如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。

1-n的全排列中，逆序数最小为0（正序），最大为n*(n-1) / 2（倒序）
给出2个数n和k，求1-n的全排列中，逆序数为k的排列有多少种？
例如：n = 4 k = 3。

1 2 3 4的排列中逆序为3的共有6个，分别是：
1 4 3 2
2 3 4 1
2 4 1 3
3 1 4 2
3 2 1 4
4 1 2 3

由于逆序排列的数量非常大，因此只需计算并输出该数 Mod 10^9 + 7的结果就可以了。
Input
第1行：一个数T，表示后面用作输入测试的数的数量。（1 <= T <= 10000)
第2 - T + 1行：每行2个数n，k。中间用空格分隔。（2 <= n <= 1000, 0 <= k <= 20000)
Output
共T行，对应逆序排列的数量 Mod (10^9 + 7)
Input示例
1
4 3
Output示例
6
*/
#include <bits/stdc++.h>
const int mod=1000000007;
int dp[1001][20001];
void init() {
	for(int i=1;i<=1000;++i) {
		dp[i][0]=1;
	}
	for(int i=2;i<=1000;++i) {
		int maxval=i*(i-1)>>1;
		for(int j=1;j<=maxval&&j<=20000;++j) {
			int temp=0;
			if(j>=i) temp=dp[i-1][j-i];
			dp[i][j]=((dp[i][j-1]+dp[i-1][j]-temp)%mod+mod)%mod;
			//减去temp可能为负数，所以需要现价+mod再取模
		}
	}
}
int main() {
	init();
	int T,n,k;
	scanf("%d",&T);
	while(T--) {
		scanf("%d %d",&n,&k);
		printf("%d\n",dp[n][k]);
	}
	return 0;
}